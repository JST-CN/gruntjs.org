<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="description" content="Grunt中文社区是由网友发起的Grunt.js中文交流社区，关注前端构建工具Grunt.js的应用推广。"><meta name="keywords" content="Grunt.js,Grunt,web前端,前端,HTML,CSS,JavaScript,js,构建,压缩,合并,发布"><title>配置任务 - Grunt 中文社区</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lato:400,700"><link rel="shortcut icon" href="../img/favicon.ico" type="image/x-icon"><link href="/atom.xml" rel="alternate" title="Grunt Blog Feed" type="application/atom+xml"><script src="/js/vendor/lib/modernizr.min.js"></script></head><body class="page-docs page-secondary"><div class="navbar navbar-inverse"><div class="navbar-inner"><div class="container"><a href="/" class="brand"><span class="logo"></span></a><div class="nav-collapse collapse"><ul class="nav"><li><a href="/docs/getting-started.html"><i class="icon-arrow-right"></i><span>新手上路</span></a></li><li><a href="/plugins.html"><i class="icon-power-cord"></i><span>插件</span></a></li><li><a href="/docs/getting-started.html"><i class="icon-document-alt-stroke"></i><span>文档</span></a></li><li><a href="/api/grunt.html"><i class="icon-cog"></i><span>API</span></a></li></ul><form class="navbar-search pull-right"><input type="text" placeholder="Search" class="search-query"></form></div><!--.nav-collapse--></div></div></div><div class="content"><div class="container configuring-tasks.html"><div class="row-fluid"><div class="span9 page"><div class="hero-unit"><h1>配置任务</h1>
<p>这个指南解释了如何使用<code>Gruntfile</code>来为你的项目配置任务。如果你还不知道Gruntfile是什么，请先阅读<a href="/getting_started.html">新手上路</a>指南并参考<a href="http://gruntjs.com/sample-gruntfile/">Gruntfile示例</a>。</p>
<h2><a class="anchor" href="#grunt" name="grunt">Grunt配置</a></h2>
<p>Grunt的任务配置都是在你Gruntfile中的<code>grunt.initConfig</code>方法中指定。这个配置主要都是一些命名任务属性(通常任务都被定义为一个对象传递给<code>grunt.initConfig</code>方法, 而任务都是作为这个对象的属性定义的)，也可以包含任意其他数据。但这些属性(其他属性)不能与你的任务所需要的属性相冲突，否则它将被忽略(一般情况下任务中的属性命名都是约定俗成的)。</p>
<p>此外，由于这本身就是JavaScript，因此你不仅限于使用JSON；你可以在这里使用任何有效的JavaScript。必要的情况下，你甚至可以以编程的方式生成配置(比如通过其他的程序生成一个或多个任务配置)。</p>
<pre><code>grunt.initConfig({
    concat: {
        //这里是concat任务的配置信息
    },
    uglify: {
        //这里是uglify任务的配置信息
    },
    //任意非任务特定属性
    my_property: &#39;whatever&#39;,
    my_src_file: [&#39;foo/*.js&#39;, &#39;bar/*.js&#39;]
});</code></pre>
<h2>任务配置和目标</h2>
<p>当运行一个任务时，Grunt会自动查找配置对象中的同名属性。多个任务可以有多个配置，每个任务可以使用任意的命名&#39;targets&#39;来定义多个任务目标。在下面的例子中，<code>concat</code>任务有名为<code>foo</code>和<code>bar</code>两个目标，而<code>uglify</code>任务仅仅只有一个名为<code>bar</code>目标。</p>
<pre><code>grunt.initConfig({
    concat: {
        foo: {
            // 这里是concat任务&#39;foo&#39;目标的选项和文件
        },
        bar: {
            // 这里是concat任务&#39;bar&#39;目标的选择和文件
        }
    },
    uglify: {
        bar: {
            // 这里是uglify任务&#39;bar&#39;目标的选项和文件
        }
    }
});</code></pre>
<p>指定一个像<code>grunt concat:foo</code>或者<code>grunt concat:bar</code>的任务和目标只会处理指定的任务目标配置，而运行<code>grunt concat</code>将遍历所有的(定义在<code>concat</code>任务中的)目标并依次处理。注意，如果一个任务使用<a href="https://github.com/gruntjs/grunt/wiki/grunt#wiki-grunt-renameTask">grunt.renameTask</a>重命名过，Grunt将在配置对象中查找新的任务名称属性。</p>
<h2><a class="anchor" href="#options" name="options">options</a></h2>
<p>在一个任务配置中，<code>options</code>属性可以用来指定覆盖属性的内置默认值。此外，每一个任务目标中更具体的目标都可以拥有一个<code>options</code>属性。目标级的选项将会覆盖任务级的选项(就近原则————<code>options</code>离目标越近,其优先级越高)。</p>
<p><code>options</code>对象是可选，如果不需要，可以省略。</p>
<pre><code>grunt.initConfig({
    concat: {
        options: {
            // 这里是任务级的Options，覆盖任务的默认值 
        },
        foo: {
            options: {
                // 这里是&#39;foo&#39;目标的options，它会覆盖任务级的options.
            }
        },
        bar: {
            // 没有指定options，这个目标将使用任务级的options
        }
    }
});</code></pre>
<h2>文件</h2>
<p>由于大多数的任务执行文件操作，Grunt有一个强大的抽象声明说明任务应该操作哪些文件。这里有好几种定义<strong>src-dest</strong>(源文件-目标文件)文件映射的方式，都提供了不同程度的描述和控制操作方式。任何一种多任务(包含多个任务目标的任务)都能理解下面的格式，所以你只需要选择满足你需求的格式就行。</p>
<p>所有的文件格式都支持<code>src</code>和<code>dest</code>属性，此外&quot;Compact&quot;[简洁]和&quot;Files Array&quot;[文件数组]格式还支持以下一些附加的属性：</p>
<ul>
<li><p><code>filter</code> 它通过接受任意一个有效的<a href="http://nodejs.org/docs/latest/api/fs.html#fs_class_fs_stats">fs.Stats方法名</a>或者一个函数来匹配<code>src</code>文件路径并根据匹配结果返回<code>true</code>或者<code>false</code>。</p>
</li>
<li><p><code>nonull</code> 当一个匹配没有被检测到时，它返回一个包含模式自身的列表。否则，如果没有任何匹配项时它返回一个空列表。结合Grunt的<code>--verbore</code>标志, 这个选项可以帮助用来调试文件路径的问题。</p>
</li>
<li><p><code>dot</code> 它允许模式模式匹配句点开头的文件名，即使模式并不明确文件名开头部分是否有句点。</p>
</li>
<li><p><code>matchBase</code> 如果设置这个属性，缺少斜线的模式(意味着模式中不能使用斜线进行文件路径的匹配)将不会匹配包含在斜线中的文件名。 例如，a?b将匹配<code>/xyz/123/acb</code>但不匹配<code>/xyz/acb/123</code>。</p>
</li>
<li><p><code>expand</code> 处理动态的<code>src-dest</code>文件映射，更多的信息请查看<a href="http://gruntjs.com/configuring-tasks#building-the-files-object-dynamically">&quot;动态构建文件对象&quot;</a>。</p>
</li>
<li><p>其他的属性将作为匹配项传递给底层的库。在<a href="https://github.com/isaacs/node-glob">node-glob</a>和<a href="https://github.com/isaacs/minimatch">minimatch</a>文档中可以查看更多选项。</p>
</li>
</ul>
<h3>简洁格式</h3>
<p>这种形式允许每个目标对应一个<strong>src-dest</strong>文件映射。通常情况下它用于只读任务，比如<a href="https://github.com/gruntjs/grunt-contrib-jshint">grunt-contrib-jshint</a>, 它就值需要一个单一的<code>src</code>属性，而不需要关联的<code>dest</code>选项. 这种格式还支持为每个<code>src-dest</code>文件映射指定附加属性。</p>
<pre><code>grunt.initConfig({
    jshint: {
        foo: {
            src: [&#39;src/aa.js&#39;, &#39;src/aaa.js&#39;]
        }
    },
    concat: {
        bar: {
            src: [&#39;src/bb.js&#39;, &#39;src/bbb.js&#39;],
            dest: &#39;dest/b.js&#39;
        }
    }
});</code></pre>
<h3>文件对象格式</h3>
<p>这种形式支持每个任务目标对应多个<code>src-dest</code>形式的文件映射，属性名就是目标文件，源文件就是它的值(源文件列表则使用数组格式声明)。可以使用这种方式指定数个<code>src-dest</code>文件映射， 但是不能够给每个映射指定附加的属性。</p>
<pre><code>grunt.initConfig({
    concat: {
        foo: {
            files: {
                &#39;dest/a.js&#39;: [&#39;src/aa.js&#39;, &#39;src/aaa.js&#39;],
                &#39;dest/a1.js&#39;: [&#39;src/aa1.js&#39;, &#39;src/aaa1.js&#39;]
            }
        },
        bar: {
            files: {
                &#39;dest/b.js&#39;: [&#39;src/bb.js&#39;, &#39;src/bbb.js&#39;],
                &#39;dest/b1.js&#39;: [&#39;src/bb1.js&#39;, &#39;src/bbb1.js&#39;]
            }
        }
    }
});</code></pre>
<h3>文件数组格式</h3>
<p>这种形式支持每个任务目标对应多个<code>src-dest</code>文件映射，同时也允许每个映射拥有附加属性：</p>
<pre><code>grunt.initConfig({
    concat: {
        foo: {
            files: [
                {src: [&#39;src/aa.js&#39;, &#39;src/aaa.js&#39;], dest: &#39;dest/a.js&#39;},
                {src: [&#39;src/aa1.js&#39;, &#39;src/aaa1.js&#39;], dest: &#39;dest/a1.js&#39;}
            ]
        },
        bar: {
            files: [
                {src: [&#39;src/bb.js&#39;, &#39;src/bbb.js&#39;], dest: &#39;dest/b/&#39;, nonull: true},
                {src: [&#39;src/bb1.js&#39;, &#39;src/bbb1.js&#39;], dest: &#39;dest/b1/&#39;, filter: &#39;isFile&#39;}
            ]
        }
    }
});</code></pre>
<h3>较老的格式</h3>
<p><strong>dest-as-target</strong>文件格式在多任务和目标形式出现之前是一个过渡形式，目标文件路径实际上就是目标名称。遗憾的是, 由于目标名称是文件路径，那么运行<code>grunt task:target</code>可能不合适。此外，你也不能指定一个目标级的<code>options</code>或者给每个<code>src-dest</code>文件映射指定附加属性。</p>
<pre><code>grunt.initConfig({
    concat: {
        &#39;dest/a.js&#39;: [&#39;src/aa.js&#39;, &#39;src/aaa.js&#39;],
        &#39;dest/b.js&#39;: [&#39;src/bb.js&#39;, &#39;src/bbb.js&#39;]
    }
});</code></pre>
<h3>自定义过滤函数</h3>
<p><code>filter</code>属性可以给你的目标文件提供一个更高级的详细帮助信息。只需要使用一个有效的<a href="http://nodejs.org/docs/latest/api/fs.html#fs_class_fs_stats">fs.Stats方法名</a>。下面的配置仅仅清理一个与模式匹配的真实的文件：</p>
<pre><code>grunt.initConfig({
    clean: {
        foo: {
            src: [&#39;temp/**/*&#39;],
            filter: &#39;isFile&#39;
        }
    }
});</code></pre>
<p>或者创建你自己的<code>filter</code>函数根据文件是否匹配来返回<code>true</code>或者<code>false</code>。下面的例子将仅仅清理一个空目录：</p>
<pre><code>grunt.initConfig({
    clean: {
        foo: {
            src: [&#39;temp/**/*&#39;],
            filter: function(filepath){
                return (grunt.file.isDir(filepath) &amp;&amp; require(&#39;fs&#39;).readdirSync(filepath).length === 0);
            }
        }
    }
});</code></pre>
<h3>通配符模式</h3>
<blockquote>
<p>原文档标题为Globbing patterns，大意是指使用一些通配符形式的匹配模式快速的匹配文件。</p>
</blockquote>
<p>通常分别指定所有源文件路径的是不切实际的(也就是将源文件-目标文件一一对应的关系列出来)，因此Grunt支持通过内置的<a href="https://github.com/isaacs/node-glob">node-glob</a>和<a href="https://github.com/isaacs/minimatch">minimatch</a>库来匹配文件名(又叫作<code>globbing</code>)。</p>
<p>当然这并不是一个综合的匹配模式方面的教程，你只需要知道如何在文件路径匹配过程中使用它们即可：</p>
<ul>
<li><p><code>*</code>匹配任意数量的字符，但不匹配<code>/</code></p>
</li>
<li><p><code>?</code>匹配单个字符，但不匹配<code>/</code></p>
</li>
<li><p><code>**</code>匹配任意数量的字符，包括<code>/</code>，只要它是路径中唯一的一部分</p>
</li>
<li><p><code>{}</code>允许使用一个逗号分割的列表或者表达式</p>
</li>
<li><p><code>!</code>在模式的开头用于否定一个匹配模式(即排除与模式匹配的信息)</p>
</li>
</ul>
<p>大多数的人都知道<code>foo/*.js</code>将匹配位于<code>foo/</code>目录下的所有的<code>.js</code>结尾的文件, 而<code>foo/**/*.js</code>将匹配<code>foo/</code>目录以及其子目录中所有以<code>.js</code>结尾的文件。</p>
<p>此外, 为了简化原本复杂的通配符模式，Grunt允许指定一个数组形式的文件路径或者一个通配符模式。模式处理的过程中，带有<code>!</code>前缀模式不包含结果集中与模式相配的文件。 而且其结果集也是唯一的。</p>
<p>示例：</p>
<pre><code>//可以指定单个文件
{src: &#39;foo/this.js&#39;, dest: …}
//或者指定一个文件数组
{src: [&#39;foo/this.js&#39;, &#39;foo/that.js&#39;, &#39;foo/the-other.js&#39;], dest: …}
//或者使用一个匹配模式
{src: &#39;foo/th*.js&#39;, dest: …}

//一个独立的node-glob模式
{src: &#39;foo/{a,b}*.js&#39;, dest: …}
//也可以这样编写
{src: [&#39;foo/a*.js&#39;, &#39;foo/b*.js&#39;], dest: …}

//foo目录中所有的.js文件，按字母排序
{src: [&#39;foo/*js&#39;], dest: …}
//这里首先是bar.js，接着是剩下的.js文件按字母排序
{src: [&#39;foo/bar.js&#39;, &#39;foo/*.js&#39;], dest: …}

//除bar.js之外的所有的.js文件，按字母排序
{src: [&#39;foo/*.js&#39;, &#39;!foo/bar.js&#39;], dest: …}
//所有.js文件按字母排序, 但是bar.js在最后.
{src: [&#39;foo/*.js&#39;, &#39;!foo/bar.js&#39;, &#39;foo/bar.js&#39;], dest: …}

//模板也可以用于文件路径或者匹配模式中
{src: [&#39;src/&lt;%= basename %&gt;.js&#39;], dest: &#39;build/&lt;%= basename %&gt;.min.js&#39;}
//它们也可以引用在配置中定义的其他文件列表
{src: [&#39;foo/*.js&#39;, &#39;&lt;%= jshint.all.src %&gt;&#39;], dest: …}</code></pre>
<p>可以在<a href="https://github.com/isaacs/node-glob">node-glob</a>和<a href="https://github.com/isaacs/minimatch">minimatch</a>文档中查看更多的关于通配符模式的语法。</p>
<h3>构建动态文件对象</h3>
<p>当你希望处理大量的单个文件时，这里有一些附加的属性可以用来动态的构建一个文件. 这些属性都可以指定在<code>Compact</code>和<code>Files Array</code>映射格式中(这两种格式都可以使用)。</p>
<ul>
<li><p><code>expand</code> 设置<code>true</code>用于启用下面的选项：</p>
</li>
<li><p><code>cwd</code> 相对于当前路径所匹配的所有<code>src</code>路径(但不包括当前路径。)</p>
</li>
<li><p><code>src</code> 相对于<code>cwd</code>路径的匹配模式。</p>
</li>
<li><p><code>dest</code> 目标文件路径前缀。</p>
</li>
<li><p><code>ext</code> 使用这个属性值替换生成的<code>dest</code>路径中所有实际存在文件的扩展名(比如我们通常将压缩后的文件命名为<code>.min.js</code>)。</p>
</li>
<li><p><code>flatten</code> 从生成的<code>dest</code>路径中移除所有的路径部分。</p>
</li>
<li><p><code>rename</code> 对每个匹配的<code>src</code>文件调用这个函数(在执行<code>ext</code>和<code>flatten</code>之后)。传递<code>dest</code>和匹配的<code>src</code>路径给它，这个函数应该返回一个新的<code>dest</code>值。 如果相同的<code>dest</code>返回不止一次，每个使用它的<code>src</code>来源都将被添加到一个数组中。</p>
</li>
</ul>
<p>在下面的例子中，<code>minify</code>任务将在<code>static_mappings</code>和<code>dynamic_mappings</code>两个目标中查看相同的<code>src-dest</code>文件映射列表, 这是因为任务运行时Grunt会自动展开<code>dynamic_mappings</code>文件对象为4个单独的静态<code>src-dest</code>文件映射--假设这4个文件能够找到。</p>
<p>可以指定任意结合的静态<code>src-dest</code>和动态的<code>src-dest</code>文件映射。</p>
<pre><code>grunt.initConfig({
    minify: {
        static_mappings: {
            //由于这里的src-dest文件映射时手动指定的, 每一次新的文件添加或者删除文件时，Gruntfile都需要更新
            files: [
                {src: &#39;lib/a.js&#39;, dest: &#39;build/a.min.js&#39;},
                {src: &#39;lib/b.js&#39;, dest: &#39;build/b.min.js&#39;},
                {src: &#39;lib/subdir/c.js&#39;, dest: &#39;build/subdir/c.min.js&#39;},
                {src: &#39;lib/subdir/d.js&#39;, dest: &#39;build/subdir/d.min.js&#39;}
            ]
        },
        dynamic_mappings: {
            //当&#39;minify&#39;任务运行时Grunt将自动在&quot;lib/&quot;下搜索&quot;**/*.js&quot;, 然后构建适当的src-dest文件映射，因此你不需要在文件添加或者移除时更新Gruntfile
            files: [
                {
                    expand: true, //启用动态扩展
                    cwd: &#39;lib/&#39;, //批匹配相对lib目录的src来源
                    src: &#39;**/*.js&#39;, //实际的匹配模式
                    dest: &#39;build/&#39;, //目标路径前缀
                    ext: &#39;.min.js&#39; //目标文件路径中文件的扩展名.
                }
            ]
        }
    }
});</code></pre>
<h3>模板</h3>
<p>使用<code>&lt;% %&gt;</code>分隔符指定的模板会在任务从配置中读取相应的数据时将自动填充。模板会以递归的方式填充，直到配置中不再存在遗留模板相关的信息(与模板匹配的)。</p>
<p>整个配置对象决定了属性上下文(模板中的属性)。此外，在模板中使用<code>grunt</code>以及它的方法都是有效的，例如： <code>&lt;%= grunt.template.today(&#39;yyyy-mm-dd&#39;) %&gt;</code>。</p>
<ul>
<li><p><code>&lt;%= prop.subprop %&gt;</code> 将会自动展开配置信息中的<code>prop.subprop</code>的值，不管是什么类型。像这样的模板不仅可以用来引用字符串值，还可以引用数组或者其他对象类型的值。</p>
</li>
<li><p><code>&lt;% %&gt;</code>执行任意内联的JavaScript代码，对于控制流或者循环来说是非常有用的。</p>
</li>
</ul>
<p>下面提供了一个<code>concat</code>任务配置示例，运行<code>grunt concat:sample</code>时将通过banner中的<code>/* abcde */</code>连同<code>foo/*.js</code>+<code>bar/*.js</code>+<code>bar/*.js</code>匹配的所有文件来生成一个名为<code>build/abcde.js</code>的文件。</p>
<pre><code>grunt.initConfig({
    concat: {
        sample: {
            options: {
                banner: &#39;/* &lt;%= baz %&gt; */\n&#39; // &#39;/* abcde */\n&#39;
            },
            src: [&#39;&lt;%= qux %&gt;&#39;, &#39;baz/*.js&#39;], // [[&#39;foo/*js&#39;, &#39;bar/*.js&#39;], &#39;baz/*.js&#39;]
            dest: &#39;build/&lt;%= baz %&gt;.js&#39;
        }
    },
    //用于任务配置模板的任意属性
    foo: &#39;c&#39;,
    bar: &#39;b&lt;%= foo %&gt;d&#39;, //&#39;bcd&#39;
    baz: &#39;a&lt;%= bar %&gt;e&#39;, //&#39;abcde&#39;
    qux: [&#39;foo/*.js&#39;, &#39;bar/*.js&#39;]
});</code></pre>
<h2>导入外部数据</h2>
<p>在下面的Gruntfile中，项目的元数据是从<code>package.json</code>文件中导入到Grunt配置中的，并且<a href="http://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify插件</a>的<code>uglify</code>任务被配置用于压缩一个源文件以及使用该元数据动态的生成一个banner注释。</p>
<p>Grunt有<code>grunt.file.readJSON</code>和<code>grunt.file.readYAML</code>两个方法分别用于引入JSON和YAML数据。</p>
<pre><code>grunt.initConfig({
    pkg: grunt.file.readJSON(&#39;package.json&#39;),
    uglify: {
        options: {
            banner: &#39;/* &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\n&#39;
        },
        dist: {
            src: &#39;src/&lt;%= pkg.name %&gt;.js&#39;,
            dest: &#39;dist/&lt;%= pkg.name %&gt;.min.js&#39;
        }
    }
});</code></pre>
<div class="end-link">在文档中发现了错误？
<a href='https://github.com/gruntjs/grunt-docs/issues'>提交错误报告</a>.</div></div></div><div class="span3"><div class="well sidebar-nav"><ul class="nav nav-list"><li class="nav-header"><i class="icon-document-alt-stroke"></i><span>文档</span></li><li><a href="/docs/getting-started.html" class="false">新手上路</a></li><li><a href="/docs/configuring-tasks.html" class="active">配置任务</a></li><li><a href="/docs/sample-gruntfile.html" class="false">Gruntfile范例</a></li><li><a href="/docs/creating-tasks.html" class="false">创建任务</a></li><li><a href="/docs/creating-plugins.html" class="false">创建插件</a></li><li><a href="/docs/using-the-cli.html" class="false">使用CLI</a></li></ul><ul class="nav nav-list"><li class="nav-header"><span>高级</span></li><li><a href="/docs/installing-grunt.html" class="false">安装Grunt</a></li><li><a href="/docs/frequently-asked-questions.html" class="false">常见问题</a></li><li><a href="/docs/project-scaffolding.html" class="false">项目脚手架</a></li></ul><ul class="nav nav-list"><li class="nav-header"><span>社区</span></li><li><a href="/docs/help-resources.html" class="false">参考资料</a></li><li><a href="/docs/who-uses-grunt.html" class="false">Grunt用户</a></li><li><a href="/docs/built-with-grunt-badge.html" class="false">使用Grunt徽章</a></li><li><a href="/docs/contributing.html" class="false">参与贡献</a></li></ul><ul class="nav nav-list"><li class="nav-header"><span>迁移指南</span></li><li><a href="/docs/upgrading-from-0.3-to-0.4.html" class="false">从0.3迁移到0.4</a></li></ul><div class="advertisements"><script>var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script><script>var ados = ados || {};ados.run = ados.run || [];ados.run.push(function() {/* load placement for account: Bocoup, site: Grunt, size: 120x90 - Button 1 and Text*/ados_add_placement(4433, 27854, "azk48893", 1);ados_load();});</script><div id="azk48893"></div><span class="adsbybocoup">Ads by <a href="http://bocoup.com">Bocoup</a>.</span></div></div></div></div></div></div><footer class="grunt-footer"><div class="inner"><div class="container"><ul class="pull-right"><li><a href="/blog.html">Blog</a></li><li><a href="/docs/upgrading-from-0.3-to-0.4.html">迁移指南</a></li><li><a href="/docs/contributing.html">参与贡献</a></li><li><a href="http://github.com/JST-CN/grunt-docs.git">参与翻译</a></li><li class="social"><a href="https://github.com/gruntjs/" alt="Grunt on GitHub"><span class="icon-github"></span></a></li><li class="social"><a href="https://twitter.com/gruntjs/" alt="Grunt on Twitter"><span class="icon-twitter"></span></a></li><li class="social"><a href="/atom.xml" alt="Grunt blog RSS feed"><span class="icon-feed"></span></a></li><li>QQ群(Grunt同学会):16613475</li></ul><ul class="pull-left"><li>Grunt开发工作由<a href="http://bocoup.com/" alt="Bocoup">Bocoup</a>资助,中文翻译由<a href="http://github.com/JST-CN/" alt="JST-CN">JST-CN</a>贡献</li></ul></div></div></footer><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-48624170-1', 'gruntjs.org');
ga('send', 'pageview');</script><script>document.write('<script type="text/javascript" src="' + ('https:'==document.location.protocol?'https://':'http://c.') + 'jslogger.com/jslogger.js"><\/script>');</script><script>window.jslogger = new JSLogger();</script><script src="http://tajs.qq.com/stats?sId=23584984"></script></body></html>